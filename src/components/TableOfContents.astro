---
import type { MarkdownHeading } from 'astro';

interface Props {
	headings?: MarkdownHeading[];
	heading?: NestedHeading;
}

interface NestedHeading extends MarkdownHeading {
	children: NestedHeading[];
}

const { headings = [] } = Astro.props;

// H2とH3のみを対象とする
const filteredHeadings = headings.filter(heading => heading.depth === 2 || heading.depth === 3);

// 見出しを階層構造に変換
function buildHierarchy(headings: MarkdownHeading[]): NestedHeading[] {
	const hierarchy: NestedHeading[] = [];
	const stack: NestedHeading[] = [];

	for (const heading of headings) {
		const nestedHeading: NestedHeading = { ...heading, children: [] };

		// 現在の見出しより深い階層をスタックから削除
		while (stack.length > 0 && stack[stack.length - 1].depth >= heading.depth) {
			stack.pop();
		}

		// 親が存在する場合は子として追加、そうでなければルートに追加
		if (stack.length === 0) {
			hierarchy.push(nestedHeading);
		} else {
			stack[stack.length - 1].children.push(nestedHeading);
		}

		stack.push(nestedHeading);
	}

	return hierarchy;
}

const nestedHeadings = buildHierarchy(filteredHeadings);

// 再帰コンポーネント用の型定義
const TableOfContentsHeading = Astro.self;
---

{nestedHeadings.length > 0 && (
	<nav class="table-of-contents" aria-label="目次" data-toc>
		<div class="toc-header">
			<h3 class="toc-title">目次</h3>
			<button 
				class="toc-toggle" 
				aria-expanded="true" 
				aria-controls="toc-list"
				data-toc-toggle
			>
				<span class="toc-toggle-icon"></span>
			</button>
		</div>
		<ul class="toc-list" id="toc-list" data-toc-list>
			{nestedHeadings.map((heading) => (
				<TableOfContentsHeading heading={heading} />
			))}
		</ul>
	</nav>
)}

{Astro.props.heading && Astro.props.heading.depth && (
	<li class={`toc-item toc-depth-${Astro.props.heading.depth}`}>
		<a 
			href={`#${Astro.props.heading.slug}`} 
			class="toc-link"
			data-toc-link={Astro.props.heading.slug}
		>
			{Astro.props.heading.text}
		</a>
		{Astro.props.heading.children && Astro.props.heading.children.length > 0 && (
			<ul class="toc-sublist">
				{Astro.props.heading.children.map((child: NestedHeading) => (
					<TableOfContentsHeading heading={child} />
				))}
			</ul>
		)}
	</li>
)}

<style>
	.table-of-contents {
		background: var(--primary-background);
		border-radius: 12px;
		box-shadow: var(--box-shadow);
		padding: 1.5rem;
		max-height: calc(100vh - 4rem);
		overflow-y: auto;
	}

	.toc-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		margin-bottom: 1rem;
		border-bottom: 1px solid oklch(90% 0.01 262);
		padding-bottom: 0.75rem;
	}

	.toc-title {
		margin: 0;
		font-size: 1.1rem;
		font-weight: 600;
		color: var(--primary-foreground);
	}

	.toc-toggle {
		display: none;
		background: none;
		border: none;
		cursor: pointer;
		padding: 0.5rem;
		border-radius: 4px;
		transition: background-color 0.2s ease;
	}

	.toc-toggle:hover {
		background: oklch(92% 0.01 262);
	}

	.toc-toggle-icon {
		display: block;
		width: 1rem;
		height: 1rem;
		position: relative;
	}

	.toc-toggle-icon::before,
	.toc-toggle-icon::after {
		content: '';
		position: absolute;
		left: 50%;
		top: 50%;
		width: 12px;
		height: 2px;
		background: var(--primary-foreground);
		border-radius: 1px;
		transition: transform 0.2s ease;
	}

	.toc-toggle-icon::before {
		transform: translate(-50%, -50%) rotate(0deg);
	}

	.toc-toggle-icon::after {
		transform: translate(-50%, -50%) rotate(90deg);
	}

	/* 折りたたんでいるとき（aria-expanded="false"）はプラス（+）を表示 */
	.toc-toggle[aria-expanded="false"] .toc-toggle-icon::after {
		transform: translate(-50%, -50%) rotate(90deg);
	}

	/* 開いているとき（aria-expanded="true"）はマイナス（-）を表示 */
	.toc-toggle[aria-expanded="true"] .toc-toggle-icon::after {
		transform: translate(-50%, -50%) rotate(0deg);
	}

	.toc-list {
		list-style: none;
		margin: 0;
		padding: 0;
		position: relative;
	}

	.toc-sublist {
		list-style: none;
		margin: 0.25rem 0 0 0;
		padding: 0;
		position: relative;
	}

	.toc-item {
		margin-bottom: 0.3rem;
		position: relative;
	}

	.toc-sublist .toc-item {
		margin-bottom: 0.2rem;
	}

	.toc-item:last-child {
		margin-bottom: 0;
	}

	/* 縦線の表示 */
	.toc-list::before {
		content: '';
		position: absolute;
		left: 4px;
		top: calc(0.5em + 12px);
		bottom: calc(0.5em + 12px);
		width: 1px;
		background: oklch(85% 0.02 262);
		z-index: 0;
	}


	.toc-link {
		display: flex;
		align-items: center;
		color: var(--primary-foreground);
		text-decoration: none;
		padding: 0.25rem 0 0.25rem 1rem;
		font-size: 0.875rem;
		line-height: 1.5;
		transition: all 0.2s ease;
		position: relative;
	}

	.toc-link::before {
		content: '';
		border-radius: 50%;
		flex-shrink: 0;
		transition: background-color 0.2s ease;
		position: absolute;
		top: 50%;
		transform: translateY(-50%);
		z-index: 1;
	}

	.toc-link:hover {
		color: var(--primary);
	}

	.toc-link.active {
		color: var(--primary);
		font-weight: 500;
	}


	/* H2の丸（大・青） */
	.toc-depth-2 > .toc-link::before {
		width: 8px;
		height: 8px;
		background: var(--primary);
		left: 0px;
	}

	/* H3の丸（小・薄い青） */
	.toc-depth-3 > .toc-link::before {
		width: 4px;
		height: 4px;
		background: var(--primary-light);
		left: 2px;
	}

	/* タブレット・デスクトップ対応（目次は固定のまま） */
	@media (min-width: 768px) {
		.toc-toggle {
			display: none;
		}
	}

	/* タブレット専用調整 */
	@media (min-width: 768px) and (max-width: 1279px) {
		.table-of-contents {
			padding: 1.25rem; /* 1.5rem → 1.25rem */
			font-size: 0.875rem; /* 14px */
		}
		
		.toc-title {
			font-size: 1rem; /* 1.1rem → 1rem */
		}
		
		.toc-link {
			padding: 0.2rem 0 0.2rem 0.875rem; /* 少しコンパクトに */
			font-size: 0.8125rem; /* 13px */
		}
		
		/* タブレットでの縦線調整 */
		.toc-list::before {
			left: 3px; /* 4px → 3px */
		}
		
		/* タブレットでの丸印調整 */
		.toc-depth-2 > .toc-link::before {
			width: 7px; /* 8px → 7px */
			height: 7px;
			left: -1px;
		}
		
		.toc-depth-3 > .toc-link::before {
			width: 3px; /* 4px → 3px */
			height: 3px;
			left: 1px;
		}
	}

	/* モバイル対応（右下固定表示） */
	@media (max-width: 767px) {
		.table-of-contents {
			position: fixed;
			bottom: 1rem;
			right: 1rem;
			top: auto;
			max-height: 70vh;
			width: min(280px, calc(100vw - 2rem));
			z-index: 1000;
			margin-bottom: 0;
			padding: 1rem;
			box-shadow: 0 4px 20px oklch(12% 0.02 262 / 0.3);
		}

		.toc-toggle {
			display: block;
		}

		.toc-list[data-collapsed="true"] {
			display: none;
		}

		.toc-title {
			font-size: 1rem;
		}

		.toc-link {
			font-size: 0.8rem;
		}

		/* 初期状態で折りたたみ */
		.toc-list {
			max-height: 300px;
			overflow-y: auto;
		}
	}
</style>

<script>
	// 目次の折りたたみ機能と階層構造の初期化
	function initTableOfContents() {
		const toggleButton = document.querySelector('[data-toc-toggle]') as HTMLButtonElement;
		const tocList = document.querySelector('[data-toc-list]') as HTMLElement;

		if (!toggleButton || !tocList) return;

		// 子項目がある親項目にクラスを追加
		const parentItems = document.querySelectorAll('.toc-depth-2');
		parentItems.forEach(item => {
			const sublist = item.querySelector('.toc-sublist');
			if (sublist && sublist.children.length > 0) {
				item.classList.add('has-children');
			}
		});

		toggleButton.addEventListener('click', () => {
			const isExpanded = toggleButton.getAttribute('aria-expanded') === 'true';
			toggleButton.setAttribute('aria-expanded', String(!isExpanded));
			tocList.setAttribute('data-collapsed', String(isExpanded));
		});

		// モバイルでは初期状態で折りたたみ
		const isMobile = window.innerWidth <= 767;
		if (isMobile) {
			toggleButton.setAttribute('aria-expanded', 'false');
			tocList.setAttribute('data-collapsed', 'true');
		}

		// リサイズ時の対応
		window.addEventListener('resize', () => {
			const isCurrentlyMobile = window.innerWidth <= 767;
			if (isCurrentlyMobile) {
				toggleButton.setAttribute('aria-expanded', 'false');
				tocList.setAttribute('data-collapsed', 'true');
			} else {
				toggleButton.setAttribute('aria-expanded', 'true');
				tocList.setAttribute('data-collapsed', 'false');
			}
		});
	}

	// アクティブ見出し追跡機能
	function initActiveHeadingTracking() {
		const tocLinks = document.querySelectorAll('[data-toc-link]') as NodeListOf<HTMLAnchorElement>;
		const headings = Array.from(tocLinks).map(link => {
			const slug = link.getAttribute('data-toc-link');
			return document.getElementById(slug || '');
		}).filter(Boolean) as HTMLElement[];

		if (headings.length === 0) return;

		function updateActiveHeading() {
			const scrollTop = window.scrollY + 100; // 100pxのオフセット
			let activeHeading: HTMLElement | null = null;

			// 現在のスクロール位置より上にある最後の見出しを見つける
			for (let i = headings.length - 1; i >= 0; i--) {
				const heading = headings[i];
				if (heading.offsetTop <= scrollTop) {
					activeHeading = heading;
					break;
				}
			}

			// 見つからない場合は最初の見出しをアクティブにする
			if (!activeHeading && headings.length > 0) {
				activeHeading = headings[0];
			}

			// 全てのリンクからactiveクラスを削除
			tocLinks.forEach(link => link.classList.remove('active'));

			// アクティブな見出しのリンクにactiveクラスを追加
			if (activeHeading) {
				const activeLink = document.querySelector(`[data-toc-link="${activeHeading.id}"]`);
				activeLink?.classList.add('active');
			}
		}

		// 初期実行
		updateActiveHeading();

		// スクロールイベントでリアルタイム更新
		let ticking = false;
		function onScroll() {
			if (!ticking) {
				requestAnimationFrame(() => {
					updateActiveHeading();
					ticking = false;
				});
				ticking = true;
			}
		}

		window.addEventListener('scroll', onScroll);
	}

	// スムーズスクロール
	function initSmoothScroll() {
		const tocLinks = document.querySelectorAll('[data-toc-link]') as NodeListOf<HTMLAnchorElement>;
		
		tocLinks.forEach(link => {
			link.addEventListener('click', (e) => {
				e.preventDefault();
				const targetId = link.getAttribute('data-toc-link');
				const targetElement = document.getElementById(targetId || '');
				
				if (targetElement) {
					targetElement.scrollIntoView({
						behavior: 'smooth',
						block: 'start'
					});
				}
			});
		});
	}

	// スクロール追従機能
	function initScrollFollowing() {
		// パフォーマンス設定
		const PERFORMANCE_CONFIG = {
			BREAKPOINTS: {
				MOBILE_MAX: 767,
				TABLET_MIN: 768,
				TABLET_MAX: 1279,
				DESKTOP_MIN: 1280
			},
			MARGINS: {
				TABLET: 24,    // 1.5rem
				DESKTOP: 32    // 2rem
			},
			THRESHOLDS: {
				TOC_MAX_WIDTH: 240,  // 15rem
				HEADER_HEIGHT: 72
			}
		};
		
		// デバイス検出システム
		const DeviceDetector = {
			// iPad検出（iOS 13以降も対応）
			isIPad(): boolean {
				return /iPad/.test(navigator.userAgent) || 
				       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
			},
			
			// Split View検出
			isSplitView(): boolean {
				if (!this.isIPad()) return false;
				// Split Viewでは画面幅が物理画面幅より小さくなる
				return window.innerWidth < screen.width;
			},
			
			// Androidデバイス検出
			isAndroid(): boolean {
				return /Android/.test(navigator.userAgent);
			},
			
			// マルチウィンドウ検出（Android）
			isMultiWindow(): boolean {
				if (!this.isAndroid()) return false;
				const heightRatio = window.innerHeight / screen.height;
				return heightRatio < 0.9;
			},
			
			// タッチデバイス検出
			isTouchDevice(): boolean {
				return 'ontouchstart' in window || 
				       navigator.maxTouchPoints > 0;
			},
			
			// 適切なレイアウトモードを取得
			getLayoutMode(width: number): 'mobile' | 'tablet' | 'desktop' {
				// Split ViewやマルチウィンドウでモバイルレイアウトにすべきiPad/Android
				if (this.isSplitView() && width < 768) {
					return 'mobile';
				}
				if (this.isMultiWindow() && width < 768) {
					return 'mobile';
				}
				
				// 通常の判定
				if (width <= 767) return 'mobile';
				if (width <= 1279) return 'tablet';
				return 'desktop';
			}
		};
		
		// 画面回転ハンドラー
		const OrientationHandler = {
			lastScrollY: 0,
			lastActiveElement: null as Element | null,
			
			// 初期化
			init(updateCallback: Function) {
				// 画面回転イベントのリスナー登録
				if ('orientation' in window) {
					window.addEventListener('orientationchange', () => {
						this.handleOrientationChange(updateCallback);
					});
				}
				
				// 代替: リサイズイベントで画面向き変更を検出
				let lastOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
				window.addEventListener('resize', () => {
					const currentOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
					if (currentOrientation !== lastOrientation) {
						lastOrientation = currentOrientation;
						this.handleOrientationChange(updateCallback);
					}
				}, { passive: true });
			},
			
			// 画面回転時の処理
			handleOrientationChange(updateCallback: Function) {
				// 現在のスクロール位置とアクティブ要素を保存
				this.preserveState();
				
				// 回転完了を待つ（iOS/Androidの違いを吸収）
				setTimeout(() => {
					updateCallback();
					this.restoreState();
				}, 100);
			},
			
			// 状態の保存
			preserveState() {
				this.lastScrollY = window.scrollY;
				const activeHeading = document.querySelector('.toc-link.active');
				if (activeHeading) {
					const targetId = activeHeading.getAttribute('data-toc-link');
					this.lastActiveElement = document.getElementById(targetId || '');
				}
			},
			
			// 状態の復元
			restoreState() {
				if (this.lastActiveElement) {
					this.lastActiveElement.scrollIntoView({ block: 'start' });
					window.scrollBy(0, -100);
				} else {
					window.scrollTo(0, this.lastScrollY);
				}
			}
		};
		
		// レイアウトモードの判定を改善
		const layoutMode = DeviceDetector.getLayoutMode(window.innerWidth);

		const tocSidebar = document.getElementById('toc-sidebar');
		const toc = document.querySelector('[data-toc]') as HTMLElement;
		if (!tocSidebar || !toc) return;
		let ticking = false;
		let articleRect: DOMRect | null = null;
		
		// DOM要素キャッシュ（パフォーマンス最適化）
		const domCache = {
			mainArticle: document.querySelector('.main-article') as HTMLElement,
			proseElement: null as HTMLElement | null
		};
		
		// 初期化時にproseElementもキャッシュ
		if (domCache.mainArticle) {
			domCache.proseElement = domCache.mainArticle.querySelector('.prose') as HTMLElement;
		}
		
		// 画面サイズキャッシュ（デバイス固有の判定を含む）
		const viewportCache = {
			width: window.innerWidth,
			layoutMode: layoutMode,
			isSplitView: DeviceDetector.isSplitView(),
			isMultiWindow: DeviceDetector.isMultiWindow(),
			
			get isTablet() { 
				// デバイス固有の判定を含める
				return this.layoutMode === 'tablet';
			},
			
			update() {
				const newWidth = window.innerWidth;
				const newLayoutMode = DeviceDetector.getLayoutMode(newWidth);
				const newSplitView = DeviceDetector.isSplitView();
				const newMultiWindow = DeviceDetector.isMultiWindow();
				
				if (newWidth !== this.width || 
				    newLayoutMode !== this.layoutMode ||
				    newSplitView !== this.isSplitView ||
				    newMultiWindow !== this.isMultiWindow) {
					
					this.width = newWidth;
					this.layoutMode = newLayoutMode;
					this.isSplitView = newSplitView;
					this.isMultiWindow = newMultiWindow;
					return true;
				}
				return false;
			}
		};

		// 記事要素の位置を取得・更新
		function updateArticlePosition() {
			if (domCache.mainArticle) {
				articleRect = domCache.mainArticle.getBoundingClientRect();
			}
		}

		// 目次の位置を更新
		function updateTocPosition() {
			// モバイルレイアウトの場合はスクロール追従を行わない
			if (viewportCache.layoutMode === 'mobile') {
				// モバイル用のスタイルをクリアしてCSSに任せる
				if (tocSidebar) {
					tocSidebar.style.position = '';
					tocSidebar.style.left = '';
					tocSidebar.style.top = '';
					tocSidebar.style.width = '';
					tocSidebar.style.maxHeight = '';
					tocSidebar.style.visibility = '';
					tocSidebar.style.opacity = '';
				}
				return;
			}

			if (!articleRect || !domCache.proseElement) return;

			const scrollY = window.scrollY;
			
			// ブログ本文（.prose）の位置を取得
			const proseRect = domCache.proseElement.getBoundingClientRect();
			const proseTop = proseRect.top + scrollY;

			// 記事の右側に配置（キャッシュされた値を使用）
			const articleRight = articleRect.right;
			
			// デバイス固有の間隔調整
			let margins = viewportCache.isTablet ? 
				PERFORMANCE_CONFIG.MARGINS.TABLET : 
				PERFORMANCE_CONFIG.MARGINS.DESKTOP;
			
			// Split View時の追加調整
			if (viewportCache.isSplitView) {
				margins = viewportCache.isTablet ? 16 : 24;
			}
			
			const gap = margins;

			// 目次をfixedに設定
			tocSidebar.style.position = 'fixed';
			tocSidebar.style.left = `${articleRight + gap}px`;
			tocSidebar.style.visibility = 'visible';
			tocSidebar.style.opacity = '1';
			tocSidebar.style.transition = 'opacity 0.2s ease, visibility 0.2s ease, top 0s';
			
			// 右端がビューポートを超えないように調整（設定値を使用）
			const tocWidth = tocSidebar.offsetWidth;
			const rightMargin = viewportCache.isTablet ? 
				PERFORMANCE_CONFIG.MARGINS.TABLET : 
				PERFORMANCE_CONFIG.MARGINS.DESKTOP * 1.5; // デスクトップは3rem相当
			const maxLeft = viewportCache.width - tocWidth - rightMargin;
			if (articleRight + gap > maxLeft) {
				tocSidebar.style.left = `${maxLeft}px`;
			}

			// デバイス固有の幅制限
			if (viewportCache.isTablet) {
				const maxTocWidth = Math.min(tocWidth, PERFORMANCE_CONFIG.THRESHOLDS.TOC_MAX_WIDTH);
				tocSidebar.style.width = `${maxTocWidth}px`;
			} else if (viewportCache.isMultiWindow) {
				// Androidマルチウィンドウでは更に制限
				const maxTocWidth = Math.min(tocWidth, 200);
				tocSidebar.style.width = `${maxTocWidth}px`;
			} else {
				tocSidebar.style.width = ''; // デスクトップでは制限を解除
			}

			// 目次の位置を計算
			let tocTop: number;
			
			// ヘッダーが表示されている場合の基本位置（設定値を使用）
			const topMargin = viewportCache.isTablet ? 
				PERFORMANCE_CONFIG.MARGINS.TABLET : 
				PERFORMANCE_CONFIG.MARGINS.DESKTOP;
			const baseTop = scrollY > PERFORMANCE_CONFIG.THRESHOLDS.HEADER_HEIGHT ? 
				topMargin : 
				PERFORMANCE_CONFIG.THRESHOLDS.HEADER_HEIGHT + topMargin;
			
			// ブログ本文の開始位置に基づいて制限
			const minTop = proseTop - scrollY;
			
			// 目次がブログ本文より上に行かないように制限
			tocTop = Math.max(baseTop, minTop);
			
			tocSidebar.style.top = `${tocTop}px`;

			// 高さの調整（設定値を使用）
			const bottomMargin = viewportCache.isTablet ? 
				PERFORMANCE_CONFIG.MARGINS.TABLET : 
				PERFORMANCE_CONFIG.MARGINS.DESKTOP;
			const maxHeight = window.innerHeight - tocTop - bottomMargin;
			tocSidebar.style.maxHeight = `${maxHeight}px`;
		}

		// スクロールイベントハンドラ
		function onScroll() {
			if (!ticking) {
				requestAnimationFrame(() => {
					updateArticlePosition();
					updateTocPosition();
					ticking = false;
				});
				ticking = true;
			}
		}

		// リサイズイベントハンドラ（最適化：画面サイズ変更時のみキャッシュ更新）
		function onResize() {
			const oldLayoutMode = viewportCache.layoutMode;
			const hasChanged = viewportCache.update();
			
			if (hasChanged) {
				// レイアウトモードが変更された場合
				if (oldLayoutMode !== viewportCache.layoutMode) {
					// mobile→tablet/desktop への変更時
					if (oldLayoutMode === 'mobile' && viewportCache.layoutMode !== 'mobile') {
						// スクロール追従機能を有効化
						updateArticlePosition();
						updateTocPosition();
						// 目次の表示を復元
						if (tocSidebar) {
							tocSidebar.style.position = 'fixed';
							tocSidebar.style.visibility = 'visible';
							tocSidebar.style.opacity = '1';
						}
					}
					// tablet/desktop→mobile への変更時
					else if (oldLayoutMode !== 'mobile' && viewportCache.layoutMode === 'mobile') {
						// 目次の位置スタイルをクリア（モバイル用CSSに任せる）
						if (tocSidebar) {
							tocSidebar.style.position = '';
							tocSidebar.style.left = '';
							tocSidebar.style.top = '';
							tocSidebar.style.width = '';
							tocSidebar.style.maxHeight = '';
						}
					}
				}
				// 同じレイアウトモード内での変更
				else {
					updateArticlePosition();
					updateTocPosition();
				}
			}
		}

		// 初期実行
		updateArticlePosition();
		updateTocPosition();

		// 画面回転ハンドラーの初期化
		OrientationHandler.init(() => {
			const oldLayoutMode = viewportCache.layoutMode;
			const hasChanged = viewportCache.update();
			
			if (hasChanged) {
				// レイアウトモードが変更された場合は完全に再初期化
				if (oldLayoutMode !== viewportCache.layoutMode) {
					// mobile→tablet/desktop への変更時は新しく初期化
					if (oldLayoutMode === 'mobile' && viewportCache.layoutMode !== 'mobile') {
						// スクロール追従機能を再開
						updateArticlePosition();
						updateTocPosition();
						// 目次の表示を復元
						if (tocSidebar) {
							tocSidebar.style.position = 'fixed';
							tocSidebar.style.visibility = 'visible';
							tocSidebar.style.opacity = '1';
						}
					}
					// tablet/desktop→mobile への変更時は無効化
					else if (oldLayoutMode !== 'mobile' && viewportCache.layoutMode === 'mobile') {
						// 目次の位置スタイルをクリア（モバイル用CSSに任せる）
						if (tocSidebar) {
							tocSidebar.style.position = '';
							tocSidebar.style.left = '';
							tocSidebar.style.top = '';
							tocSidebar.style.width = '';
							tocSidebar.style.maxHeight = '';
							tocSidebar.style.visibility = '';
							tocSidebar.style.opacity = '';
						}
					}
				}
				// 同じレイアウトモード内での変更は通常の更新
				else {
					updateArticlePosition();
					updateTocPosition();
				}
			}
		});
		
		// タッチデバイス最適化
		if (DeviceDetector.isTouchDevice()) {
			// タップ領域を拡大
			const tocLinks = document.querySelectorAll('.toc-link');
			tocLinks.forEach(link => {
				(link as HTMLElement).style.minHeight = '44px';
				(link as HTMLElement).style.paddingTop = '10px';
				(link as HTMLElement).style.paddingBottom = '10px';
			});
			
			// 慣性スクロール対応
			let isScrolling = false;
			let scrollTimeout: number;
			
			window.addEventListener('scroll', () => {
				if (!isScrolling && tocSidebar) {
					isScrolling = true;
					tocSidebar.style.pointerEvents = 'none';
				}
				
				clearTimeout(scrollTimeout);
				scrollTimeout = window.setTimeout(() => {
					isScrolling = false;
					if (tocSidebar) {
						tocSidebar.style.pointerEvents = 'auto';
					}
				}, 150);
			}, { passive: true });
		}
		
		// イベントリスナー設定（passive: true でパフォーマンス最適化）
		window.addEventListener('scroll', onScroll, { passive: true });
		window.addEventListener('resize', onResize, { passive: true });

		// クリーンアップ
		return () => {
			window.removeEventListener('scroll', onScroll);
			window.removeEventListener('resize', onResize);
		};
	}

	// ページ読み込み時とナビゲーション時に実行
	document.addEventListener('DOMContentLoaded', () => {
		initTableOfContents();
		initActiveHeadingTracking();
		initSmoothScroll();
		initScrollFollowing();
	});

	// Astroのナビゲーション後にも実行
	document.addEventListener('astro:page-load', () => {
		initTableOfContents();
		initActiveHeadingTracking();
		initSmoothScroll();
		initScrollFollowing();
	});
</script>